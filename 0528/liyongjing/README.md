## 队列(Queue)

队列是先进先出(FIFO)数据结构。如果我们从左往右加数据，有两个属性，第一个是写W的位置，第二个是读R的位置。

### 需要解决的问题

比如说写满了以后就不能写了，比如写满了，接下来读操作，读到位置3，那么1-2空间就重新可用了，写的位置就会调整到位置1，这就有个麻烦，W可能大于R，也可能小于R，我们怎么处理这个呢？

记录当前元素数量记录W和R的位置，因为W和R默认都为0，当往里面写的时候数量会递增，当数量等于容量的时候表示满了，假如数据数量是2，在位置2和位置3，W写的时候写在位置4，写满了，这时候数据数据不等于容量，怎么知道W需要回头呢。所以W和R除了要和数据数量比较还需要和容量即最后一个索引号比较。如果等于最大的索引号，W就需要回头。

### 实现原理

假设有一个容器，4个格子，我们有个指针一直做加法，那么到一定程度就超出了容器的限制，不管这个指针超出多大，我们对于指针与容量取模操作结果值肯定是在容量范围之内。

队列R和W最大的麻烦是队列有长度限制，因为有长度限制，所以R和W有回头操作，假如长度没有限制无限长，那么W永远大于等于R，W减去R肯定是当前数据长度。

假如这个队列是个环状的，那么R到W区域就是有数据的。我们用抽象大小的环来处理R和W的值，第一个用抽象的处理R和W，避免R和W回头操作，第二个在数据读写的时候，去做取模操作，因为取模操作就可以映射到真实的容量具体的位置上面，那么接下来需要判断事就很简单，要么写满了，要么是空的没数据。

### 代码实现

数据结构有三个属性，一个数组，一个读一个写，写的位置作为头，读的位置作为尾。头和尾之间就是数据。

往里面写的时候，先判断下当前是否有真实的地方有空位，假如无限大小的，cap-(W-R)就是是否有空位，那么W和R一直累加和总长度没有关系的，这样的话首先判断是否有空位，如果空位等于零就表示已经满了，直接返回一个错误。如果没有满，把尾部的信息取模操作就是把抽象的环映射到真实的数据结构上面。接下来在真实位置写，然后把抽象环上的W值累加。读操作其实也是一样的。

## 栈(Stack)

栈是先进后出(FILO)数据结构。之前的调用堆栈是一个栈结构，它是一个内存空间，地址从高位到低位分配，首先高位使用BP寄存器记录一个位置，另外一个位置用SP寄存器来处理当前栈顶的位置。Push操作SP往上减，Pop操作SP往下增。

这样用一个数组加两个字段来模拟SP、BP就可以了。使用一个数组，把位置一当作BP寄存器使用，把索引0当作BP来用，以后就是操作数组后面的空间。

### 代码实现

首先初始化的时候0指向栈底的位置，然后往里加数据的时候BP往上移，所以BP初始化的时候指向最后一个位置。

加数据的时候，读取BP寄存器的值，先判断栈是否已经满了，满了的话返回一个错误，如果不满的话直接把数据写进去，BP寄存器往上移一次，表示下次可以往新的地方写。

弹出数据的时候，BP寄存器记录的是最后一次可写的位置，首先加上1调整BP寄存器位置，如果这个位置指向最低的时候表示没有数据了，如果有数据就返回，同时调整BP寄存器。

## 链表(Linked List)

todo

## 缓冲区(Pool)

todo